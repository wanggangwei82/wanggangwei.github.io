\documentclass[a4paper,11pt]{article}
\usepackage{ctex}



\usepackage{amsmath,amssymb}             % AMS Math
\usepackage[T1]{fontenc}



\usepackage{graphicx}
% \usepackage{epstopdf}
\usepackage{tikz}
\usepackage[left=1.5in,right=1.3in,top=1.1in,bottom=1.1in,includefoot,includehead,headheight=13.6pt]{geometry}
\renewcommand{\baselinestretch}{1.05}



\usepackage{minitoc}
\newtheorem{thm}{定理}[section]
\newtheorem{prop}[thm]{命题}
\newtheorem{coro}[thm]{推论}
\newtheorem{defi}[thm]{定义}
\newtheorem{lem}[thm]{引理}
\newtheorem{exa}[thm]{例}
\newtheorem{ex}[thm]{习题}
\newtheorem{conj}[thm]{猜想}

\def\qed{\nopagebreak\hfill{\rule{4pt}{7pt}}\medbreak}
\def\pf{{\bf 证明~~ }}
\def \sg{\sigma}
\def \asc{\mathrm{asc}}
\def \des{\mathrm{des}}
\def \fix{\mathrm{fix}}
\def \lef{\mathrm{lef}}
\def \one{\mathrm{one}}
\def \Des{\mathrm{Des}}
\def \maj{\mathrm{maj}}
\def \exc{\mathrm{exc}}
\def \inv{\mathrm{inv}}
\def \roots{\mathrm{roots}}
\def \sgn{\mathrm{sgn}}
% Table of contents for each chapter

\usepackage{color}
\definecolor{linkcol}{rgb}{0,0,0.4}
\definecolor{citecol}{rgb}{0.5,0,0}

  \usepackage{graphicx}
  \DeclareGraphicsExtensions{.eps}
  \usepackage[a4paper,pagebackref,hyperindex=true,pdfnewwindow=true]{hyperref}

% \usepackage{chapterbib}
\begin{document}




\section{排列与杨表的对应}

\subsection{杨表}
杨表(Young tableau)是由杨（R.A.
Young）在1901年研究不变量理论时引入的，它在组合数学、群表示论、数学物理
等领域中都有重要应用。通常情况下，杨表是指定义在
杨图上的半标准杨表。

给定一个整数分拆$\lambda=(\lambda_1,\lambda_2,
\ldots,\lambda_k)$，与$\lambda$对应的
杨图(Young Diagram)定义为平面上一些左对齐的$k$行方块的集合，
使得第$i$行恰有$\lambda_i$个方块。例如，分拆$(4,2,1)$对应的杨图为
\begin{figure}[h]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}
\end{picture}
\end{center}
\end{figure}

在$\lambda$对应的杨图中，用正整数填充图中的每个方块得到一个阵列$T$，
若其每行递增每列严格递增，则称$T$为具有形状$\lambda$的
半标准杨表SSYT（semistandard Young
tableau），并记$\mathrm{sh}(T)=\lambda$。如果$T$中含有$\alpha_i$个$i$，那么称$(\alpha_1,\alpha_2,\ldots)$为
$T$的 类型（type）。例如，下面半标准杨表的类型为$(1,2,2,1,1)$。
\begin{figure}[ht]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}

 \put(4,22){1}  \put(14,22){2}
\put(24,22){3}\put(34,22){3} \put(4,12){2}
 \put(14,12){5}
\put(4,2){4}
\end{picture}
\end{center}
\end{figure}

设$\lambda$是$n$的一个分拆。
若用${1,2,\ldots,n}$填充$\lambda$对应的杨图使得每个数字恰好出现一次，
并且每行每列递增，则称这样的阵列为具有形状$\lambda$的
标准杨表SYT（standard Young tableau）。
例如下图是一个形状为$(4,2,1)$的标准杨表。

\begin{figure}[ht]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}
\put(4,22){1}  \put(14,22){3} \put(24,22){6}\put(34,22){7}
\put(4,12){2}
 \put(14,12){5}
\put(4,2){4}
\end{picture}
\end{center}
\end{figure}


\subsection{RSK算法}

RSK算法是根据罗宾森 （G.B. Robinson），森斯特德（C.E.
Schensted），克努斯 （D.E. Knuth）
的名字命名的，它是对称函数领域里一个优美的组合对应。
RSK算法最初是在试图证明
李特尔伍德-里查德森法则时作为一个工具由罗宾森于1938年提出的，
后又被森斯特德于1961年在研究排列的最长递增和递降子序列时重新发现，而
克努斯于1970年将RSK算法从排列推广到了广义置换（generalized
permutaition）上。
关于更多的RSK算法的介绍可见Stanley书\cite{Stanley1999}.


RSK算法的基本运算是行插入算法，即把整数$i$插入行递增和列严格递增的一个
表格$T$中，即$T$是一个半标准杨表。
把$i$插入$T$后，我们就得到了一个新的表格，记为$T\leftarrow i$,
仍旧满足行递增和列严格递增。如果$S$是$T$中的值组成的集合，则$S \cup
\{i\}$就是$T\leftarrow
i$中的值组成的集合。现在我们就来介绍如何递归地定义$T\leftarrow i$.

\begin{itemize}
  \item 如果$T$的第一行是空行或者第一行上的最大值小于$i$,
  则把$i$插入到第一行的末尾。
  \item 否则，找到第一行中第一个满足大于$i$的数字$j$, 用$i$取代$j$,
  然后用同样的原则把$j$插入第二行。继续这种算法，直到某个数插入
  某一行的末尾即停止(或者在原来的表格中新增了一行)。
\end{itemize}

同时，我们可以定义与之对应的$insertion\
 path$，即$T$中所有的那些在这些行插入的过程中改变过的位置的集合，
 记为$I(T\leftarrow i)$。

\begin{exa}
下面是相应的一个简单的例子：
\end{exa}

\begin{picture}(250,120)(-20,5)
\put(45,110){i=5} \put(0,70){T=} \put(30,90){2} \put(45,90){3}
\put(60,90){3} \put(75,90){6} \put(90,90){7} \put(30,75){4}
\put(45,75){5} \put(60,75){5} \put(75,75){7} \put(30,60){6}
\put(45,60){6} \put(60,60){8} \put(30,45){9}
\put(140,70){$T\leftarrow i=$} \put(200,90){2} \put(215,90){3}
\put(230,90){3} \put(245,90){\textbf{5}} \put(260,90){7}
\put(200,75){4} \put(215,75){5} \put(230,75){5}
\put(245,75){\textbf{6}} \put(200,60){6} \put(215,60){6}
\put(230,60){\textbf{7}} \put(200,45){\textbf{8}}
\put(200,30){\textbf{9}} \put(0,10){$I(T\leftarrow i)= \{(1,4),
(2,4), (3,3), (4,1), (5,1)\}$}
\end{picture}

关于更多的RSK算法的介绍可见Sagan书\cite{Sagan}第三章
和Stanley书\cite{Stanley1999}第七章。

令$w=a_1a_2\cdots a_n \in S_n$, 令$\emptyset$为空表格。定义
\[ P_i=P_i(w)=(\cdots ((\emptyset \leftarrow a_1)\leftarrow a_2)
\leftarrow \cdots \leftarrow a_i).\]
也就是说，$P_i$是从空表格出发，依次插入$a_1,a_2,\ldots,a_i$而得的。
此时$P_i$可以看成是一个标准杨表，除了它的值可以为任意的不同整数，
而不是
仅仅限制为$1,2,\ldots,n$. 记$P=P(w)=P_n(w)$. 定义$Q_0=\emptyset$,
当$Q_{i-1}$确定好之后，定义$ Q_i=Q_i(w)$为是在$Q_{i-1}$中插入$i$,
使得$Q_i$和$P_i$具有相同的形状，且不改变$Q_{i-1}$中任何元素的位置和值。
记$Q=Q(w)=Q_n(w)$,
最后定义RSK算法作用在$w$上后的输出值为一对杨表$(P,Q)$, 记作$w
\xrightarrow[]{\text{RSK}}(P,Q)$.



例如，我们对排列$\pi=256384197$运用RSK算法，对应的$(P,Q)$可有如下过程生成。
\newpage
\begin{picture}(100,50)
\put(35,40){\line(1,0){15}}\put(35,40){\line(0,-1){15}}\put(35,25){\line(1,0){15}}\put(50,40){\line(0,-1){15}}
\put(40,29){2}\put(40,50){$P_i$}

\put(285,40){\line(1,0){15}}\put(285,40){\line(0,-1){15}}\put(285,25){\line(1,0){15}}\put(300,40){\line(0,-1){15}}
\put(290,29){1}\put(290,50){$Q_i$}

\put(28,0){\line(1,0){30}}\put(28,-15){\line(1,0){30}}\put(28,0){\line(0,-1){15}}\put(43,0){\line(0,-1){15}}\put(58,0){\line(0,-1){15}}
\put(33,-11){2}\put(48,-11){5}

\put(278,0){\line(1,0){30}}\put(278,-15){\line(1,0){30}}\put(278,0){\line(0,-1){15}}\put(293,0){\line(0,-1){15}}\put(308,0){\line(0,-1){15}}
\put(283,-11){1}\put(298,-11){2}

\put(20,-40){\line(1,0){45}} \put(20,-55){\line(1,0){45}}
\put(20,-40){\line(0,-1){15}}\put(35,-40){\line(0,-1){15}}\put(50,-40){\line(0,-1){15}}\put(65,-40){\line(0,-1){15}}
\put(25,-51){2}\put(40,-51){5}\put(55,-51){6}

\put(270,-40){\line(1,0){45}} \put(270,-55){\line(1,0){45}}
\put(270,-40){\line(0,-1){15}}\put(285,-40){\line(0,-1){15}}\put(300,-40){\line(0,-1){15}}\put(315,-40){\line(0,-1){15}}
\put(275,-51){1}\put(290,-51){2}\put(305,-51){3}

\put(20,-80){\line(1,0){45}} \put(20,-95){\line(1,0){45}}
\put(20,-110){\line(1,0){15}}\put(20,-80){\line(0,-1){30}}\put(35,-80){\line(0,-1){30}}\put(50,-80){\line(0,-1){15}}
\put(65,-80){\line(0,-1){15}}\put(25,-91){2}\put(40,-91){3}\put(55,-91){6}\put(25,-106){5}

\put(270,-80){\line(1,0){45}} \put(270,-95){\line(1,0){45}}
\put(270,-110){\line(1,0){15}}\put(270,-80){\line(0,-1){30}}\put(285,-80){\line(0,-1){30}}\put(300,-80){\line(0,-1){15}}
\put(315,-80){\line(0,-1){15}}\put(275,-91){1}\put(290,-91){2}\put(305,-91){3}\put(275,-106){4}

\put(13,-135){\line(1,0){60}}\put(13,-150){\line(1,0){60}}\put(13,-165){\line(1,0){15}}\put(13,-135){\line(0,-1){30}}
\put(28,-135){\line(0,-1){30}}\put(43,-135){\line(0,-1){15}}\put(58,-135){\line(0,-1){15}}\put(73,-135){\line(0,-1){15}}
\put(18,-146){2}\put(33,-146){3}\put(48,-146){6}\put(63,-146){8}\put(18,-161){5}

\put(263,-135){\line(1,0){60}}\put(263,-150){\line(1,0){60}}\put(263,-165){\line(1,0){15}}\put(263,-135){\line(0,-1){30}}
\put(278,-135){\line(0,-1){30}}\put(293,-135){\line(0,-1){15}}\put(308,-135){\line(0,-1){15}}\put(323,-135){\line(0,-1){15}}
\put(268,-146){1}\put(283,-146){2}\put(298,-146){3}\put(313,-146){5}\put(268,-161){4}

\put(13,-190){\line(1,0){60}}\put(13,-205){\line(1,0){60}}\put(13,-220){\line(1,0){30}}\put(13,-190){\line(0,-1){30}}
\put(28,-190){\line(0,-1){30}}\put(43,-190){\line(0,-1){30}}\put(58,-190){\line(0,-1){15}}\put(73,-190){\line(0,-1){15}}
\put(18,-201){2}\put(33,-201){3}\put(48,-201){4}\put(63,-201){8}\put(18,-216){5}\put(33,-216){6}

\put(263,-190){\line(1,0){60}}\put(263,-205){\line(1,0){60}}\put(263,-220){\line(1,0){30}}\put(263,-190){\line(0,-1){30}}
\put(278,-190){\line(0,-1){30}}\put(293,-190){\line(0,-1){30}}\put(308,-190){\line(0,-1){15}}\put(323,-190){\line(0,-1){15}}
\put(268,-201){1}\put(283,-201){2}\put(298,-201){3}\put(313,-201){5}\put(268,-216){4}\put(283,-216){6}
\end{picture}
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\


\begin{picture}(100,50)
\put(13,50){\line(1,0){60}}\put(13,35){\line(1,0){60}}\put(13,20){\line(1,0){30}}\put(13,5){\line(1,0){15}}
\put(13,50){\line(0,-1){45}}\put(28,50){\line(0,-1){45}}\put(43,50){\line(0,-1){30}}\put(58,50){\line(0,-1){15}}
\put(73,50){\line(0,-1){15}}\put(18,39){1}\put(33,39){3}\put(48,39){4}\put(63,39){8}\put(18,24){2}\put(33,24){6}\put(18,9){5}

\put(263,50){\line(1,0){60}}\put(263,35){\line(1,0){60}}\put(263,20){\line(1,0){30}}\put(263,5){\line(1,0){15}}
\put(263,50){\line(0,-1){45}}\put(278,50){\line(0,-1){45}}\put(293,50){\line(0,-1){30}}\put(308,50){\line(0,-1){15}}
\put(323,50){\line(0,-1){15}}\put(268,39){1}\put(283,39){2}\put(298,39){3}\put(313,39){5}\put(268,24){4}\put(283,24){6}\put(268,9){7}

\put(5,-20){\line(1,0){75}}\put(5,-35){\line(1,0){75}}\put(5,-50){\line(1,0){30}}\put(5,-65){\line(1,0){15}}
\put(5,-20){\line(0,-1){45}}\put(20,-20){\line(0,-1){45}}\put(35,-20){\line(0,-1){30}}\put(50,-20){\line(0,-1){15}}
\put(65,-20){\line(0,-1){15}}\put(80,-20){\line(0,-1){15}}\put(10,-31){1}\put(25,-31){3}\put(40,-31){4}\put(55,-31){8}
\put(70,-31){9}\put(10,-46){2}\put(25,-46){6}\put(10,-61){5}

\put(255,-20){\line(1,0){75}}\put(255,-35){\line(1,0){75}}\put(255,-50){\line(1,0){30}}\put(255,-65){\line(1,0){15}}
\put(255,-20){\line(0,-1){45}}\put(270,-20){\line(0,-1){45}}\put(285,-20){\line(0,-1){30}}\put(300,-20){\line(0,-1){15}}
\put(315,-20){\line(0,-1){15}}\put(330,-20){\line(0,-1){15}}\put(260,-31){1}\put(275,-31){2}\put(290,-31){3}\put(305,-31){5}
\put(320,-31){8}\put(260,-46){4}\put(275,-46){6}\put(260,-61){7}


\put(5,-90){\line(1,0){75}}\put(5,-105){\line(1,0){75}}\put(5,-120){\line(1,0){45}}\put(5,-135){\line(1,0){15}}
\put(5,-90){\line(0,-1){45}}\put(20,-90){\line(0,-1){45}}\put(35,-90){\line(0,-1){30}}\put(50,-90){\line(0,-1){30}}
\put(65,-90){\line(0,-1){15}}\put(80,-90){\line(0,-1){15}}
\put(10,-101){1}\put(25,-101){3}\put(40,-101){4}\put(55,-101){7}\put(70,-101){9}\put(10,-116){2}\put(25,-116){6}
\put(40,-116){8}\put(10,-131){5}

\put(255,-90){\line(1,0){75}}\put(255,-105){\line(1,0){75}}\put(255,-120){\line(1,0){45}}\put(255,-135){\line(1,0){15}}
\put(255,-90){\line(0,-1){45}}\put(270,-90){\line(0,-1){45}}\put(285,-90){\line(0,-1){30}}\put(300,-90){\line(0,-1){30}}
\put(315,-90){\line(0,-1){15}}\put(330,-90){\line(0,-1){15}}
\put(260,-101){1}\put(275,-101){2}\put(290,-101){3}\put(305,-101){5}\put(320,-101){8}\put(260,-116){4}\put(275,-116){6}
\put(290,-116){9}\put(260,-131){7}
\end{picture}
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\begin{thm}
令$\mathcal{T}_{n}=\{(T_{1},
T_{2})|T_{1}$和$T_{2}$是两个形状均为$\lambda\mapsto
n$的标准杨表$\}$，则
RSK算法给出了$[n]$上的排列集合$S_n$和集合$\mathcal{T}_{n}$
之间的一一对应。
\end{thm}
\pf 记映射\[\varphi: S\mapsto \mathcal{T}_{n}, w=a_{1}a_{2}\cdots
a_{n}\mapsto (T_{1}, T_{2})\]为RSK算法后所对应的那个映射。

下面来考虑$\varphi^{-1}$。对任一$(P, Q)=(P(n), Q(n))\in
\mathcal{T}_{n}$，假定$Q_{rs}=n$，即$n$在$Q$的第$r$行第$s$列的位置。则令$Q(n-1)=Q(n)\setminus
n$。不难知道，$P_{rs}$是将$\pi_{n}$插入$P(n-1)$后对应的$insertion\
 path$中最后一个位置的元素。事实上，不难得到$P(n-1)\leftarrow \pi_{n}$的逆过程：$P_{rs}$一定是被$P$的第$r-1$
 行中最靠右的比$P_{rs}$小的元素不妨设为$P_{r-1, t}$挤入第$r$行的。因此，从$P$中移去$P_{rs}$所在的方格，将$P_{r-1, t}$
 用$P_{rs}$代换，然后继续将第$r-2$行中最靠右的比$P_{r-1, t}$小的元素用$P_{r-1, t}$代换，$\ldots$，最后，必然从$P$中挤出了某元素即为$\pi_{n}$。至此，我们由$(P(n), Q(n))$唯一得到了$(n,
\pi_{n})$和$(P(n-1),
Q(n-1))$，如此继续，最终可得置换$\left(\begin{array}{cccc}
1&2&\cdots&n\\\pi_1&\pi_2&\cdots&\pi_n\end{array}\right)$。\qed

如果$w \xrightarrow[]{\text{RSK}}(P,Q)$,
且$P,Q$具有相同的形状$\lambda$, 则我们称$w$具有形状$\lambda$,
记为$\lambda=\mathrm{sh}(w)$.
$\lambda$的共轭分拆$\lambda'=(\lambda_1',\lambda_2',\ldots)$,
其对应的表格是把$\lambda$的表格翻转而得。等价地说，$j$在$\lambda'$中出现
的次数为$\lambda_j-\lambda_{j+1}$.
记$l(\lambda)$为分拆$\lambda$中非零部分的个数，所以$l(\lambda)=\lambda_1'$.

$w$的一个递增子序列是指一个子序列$a_{i_1},a_{i_2},\ldots,a_{i_k}$满足
$a_{i_1}<a_{i_2}<\cdots<a_{i_k}$,
类似地可以定义递减子序列。例如，若$w=5\,6\,4\,2\,7\,1\,3$,
则$5\,6\,7$是一个递增子序列，$5\,4\,3$是一个递减子序列。令$\mathrm{is}(w)
 (\mathrm{ds}(w))$为$w$中的最长递增（递减）子序列的长度。对于如上的$w$, 我们
 有$\mathrm{is}(w) = 3$ (对应于$5\,6\,7$), $\mathrm{ds}(w) =
4$ (对应于序列$5\,4\,2\,1$或$6\,4\,2\,1$).
由RSK算法，我们可以发现$T_{1}$中第一行的方格总数即为$a=a_{1}a_{2}\cdots
a_{n}$的最长递增子列的长度；$T_{1}$中第一列的方格总数即为$a=a_{1}a_{2}\cdots
a_{n}$的最长递减子列的长度。所以我们可以得到以下关于
排列中的最长的递增或递减子序列的长度与对于杨表之间的
关系。
\begin{thm}
令$w \in S_n$, 且$\mathrm{sh}(w)=\lambda$, 则
\begin{eqnarray}
\mathrm{is}(w)&=&\lambda_1,\\
 \mathrm{ds}(w)&=&\lambda_1'.
\end{eqnarray}
\end{thm}


下面我们考虑置换$\pi$与其逆置换$\pi^{-1 }$在RSK算法下所对应的杨表
之间的相互关系。


\begin{thm} 若 $\pi\in S_n$ 并且
$\pi\xrightarrow{\text{RSK}}(P, Q)$，则对 $\pi$ 的逆 $\pi^{-1 }$，有
$\pi^{-1 }\xrightarrow{\text{RSK}}(Q, P)$。
\end{thm}

\pf 设 $\pi=\left(\begin{array}{cccc}
1&2&\cdots&n\\v_1&v_2&\cdots&v_n\end{array}\right)$=
$\left(\begin{array}{c}
u\\v\end{array}\right)$, $\pi^{-1 }=\left(\begin{array}{c}
v\\u\end{array}\right)_{sorted}$ (即适当排列使得
$\left(\begin{array}{c} v\\u\end{array}\right)_{sorted}$
中第一行元素递增)。按如下方式定义 inversion poset
$I=I\left(\begin{array}{c} u\\v\end{array}\right)$：

$\left(\begin{array}{c} u\\v\end{array}\right)$ 的每列定义为 $I$
中的每个点，若 $a<c, b<d$，则在 $I$ 中 $ab<cd$ (为方便起见，将
$\begin{array}{c} a\\b\end{array}$ 记为 $ab$)。

由 $I(A)$ 的定义容易得到下面的引理。


\begin{lem}  映射 $\varphi: I\left(\begin{array}{c}
u\\v\end{array}\right)\rightarrow I\left(\begin{array}{c}
v\\u\end{array}\right)$ \ \ $\varphi(ab)=ba$ 是
$I\left(\begin{array}{c} u\\v\end{array}\right)$ 到
$I\left(\begin{array}{c} v\\u\end{array}\right)$ 的同构。\end{lem}


定义 $I_1$ 是 $I$ 中最小元的集合，$I_2$ 是 $I-I_1$
中最小元的集合，$I_3$ 是 $I-I_1-I_2$
中最小元的集合，$\cdots$。注意，易知 $I_i$ 是 $I$
中的反链即它的元素可以记为：$(u_{i1}, v_{i1}), (u_{i2}, v_{i2}),
\ldots, (u_{in_i}, v_{in_i})$ 使得 $u_{i1}<u_{i2}<\cdots<u_{in_i}$
且
$v_{i1}>v_{i2}>\cdots>v_{in_i}(n_i=|I_i|)$。
我们假定以下反链中的元素都作如此标记。


\begin{lem}\label{ya}  若 $I_1, I_2, \ldots, I_d$ 是如上标记的 $I$ 的非空反链，则 $P$ 的第一行元素是 $v_{1n_1}v_{2n_2}\cdots
v_{dn_d}$，$Q$ 的第一行元素是 $u_{11}u_{21}\cdots u_{d1}$。并且，若
$(u_k, v_k)\in I_i$，则 $v_k$ 在 RSK 算法执行过程中被插入 $P(k-1)$
第一行的第 $i$ 个位置。
\end{lem}


\noindent {\bf{引理\ref{ya}的证明}} 通过对 $n$ 归纳来证此引理。$n=1$
时显然结果是平凡的。假设对 $n-1$ 时此引理成立，并且令
$\left(\begin{array}{c}
u\\v\end{array}\right)=\left(\begin{array}{cccc}
1&2&\cdots&n\\v_1&v_2&\cdots&v_n\end{array}\right)$，
$\left(\begin{array}{c}
\tilde{u}\\\tilde{v}\end{array}\right)=\left(\begin{array}{cccc}
1&2&\cdots&n-1\\v_1&v_2&\cdots&v_{n-1}\end{array}\right)$。 设
$(P(n-1), Q(n-1))$ 是插入 $v_1, \ldots, v_{n-1}$ 后所得到的
tableau，$I_i^{'} :=I_i\left(\begin{array}{c}
\tilde{u}\\\tilde{v}\end{array}\right)=\{(\tilde{u}_{i_1},
\tilde{v}_{i_1}),  (\tilde{u}_{i_2}, \tilde{v}_{i_2}), \ldots,
(\tilde{u}_{im_i}, \tilde{v}_{im_i})\},\\ 1\leq i\leq e(e=d-1$ 或
$e=d)$。由归纳假设易知，$P(n-1)$ 的第一行是
$\tilde{v}_{1m_1}\tilde{v}_{2m_2}\cdots\tilde{v}_{em_e}$，$Q(n-1)$
的第一行是
$\tilde{u}_{11}\tilde{u}_{21}\cdots\tilde{u}_{e1}$。现在将 $v_n$
插入 $P(n-1)$。若 $\tilde{v}_{im_i}>v_n$，则 $I_i^{'}\cup (u_n,
v_n)$ 是 $I\left(\begin{array}{c} u\\v\end{array}\right)$
的一个反链。因此易知若 $i$ 是最小的满足 $\tilde{v}_{im_i}>v_n$
的下标，则 $(u_n, v_n)\in I_i\left(\begin{array}{c}
u\\v\end{array}\right)$；若不存在这样的 $i$，则 $I_d=\{(u_n,
v_n)\}$。从而此引理得证。

 若记 $I_i\left(\begin{array}{c}
u\\v\end{array}\right)=\{(u_{i1},v_{i1}), (u_{i2},v_{i2}),\ldots,
(u_{im_i},v_{im_i})\}$ 且其中有 $u_{i1}<u_{i2}<\cdots<u_{im_i},
v_{i1}>v_{i2}>\cdots>v_{im_i}$ 成立，则 $I_i\left(\begin{array}{c}
v\\u\end{array}\right)=\{(v_{im_i}, u_{im_i}), \ldots,\\ (v_{i2},
u_{i2}), (v_{i1}, u_{i1})\}$ 且 $v_{im_i}<\cdots<v_{i2}<v_{i1},
u_{im_i}>\cdots>u_{i2}>u_{i1}$。因此若 $\pi^{-1
}\xrightarrow{\text{RSK}}(P^{'}, Q^{'})$，则由引理 1.3 知 $P^{'}$
的第一行元素是 $u_{11}u_{21}\cdots u_{d1}$，$Q^{'}$ 的第一行元素是
$v_{1m_1}v_{2m_2}\cdots v_{dm_d}$。即 $P^{'}, Q^{'}$ 的第一行元素与
$Q, P$ 的第一行元素分别相等。

易知，在 RSK 算法执行过程中，$v_{ij}(1\leq j<m_i)$ 比 $v_{rs}(1\leq
s<m_r)$ 先被挤入第二行当且仅当 $u_{i, j+1}<u_{r, s+1}$。设
$\overline{P}, \overline{Q}$ 分别表示移去 $P, Q$ 第一行后所得的
tableau，从而有

\begin{align*}
\left(\begin{array}{c} a\\b\end{array}\right)
&:=\left(\begin{array}{cccccccccc}
u_{12}&\cdots&u_{1m_1}&u_{22}&\cdots&u_{2m_2}&\cdots&u_{d2}&\cdots&u_{dm_d}\\v_{11}&\cdots&v_{1,
m_1-1}&v_{21}&\cdots&v_{2, m_2-1}&\cdots&v_{d1}&\cdots&v_{d,
m_d-1}\end{array}\right)_{sorted}\\&\xrightarrow{\text{RSK}}(\overline{P}
, \overline{Q}).
\end{align*}



设 $\overline{P}^{'}, \overline{Q}^{'}$ 分别表示移去 $P^{'}, Q^{'}$
第一行后所得的 tableau，对 $\left(\begin{array}{c}
v\\u\end{array}\right)$ 进行类似讨论有：


\begin{align*}
 \left(\begin{array}{c}
a^{'}\\b^{'}\end{array}\right) &:=\left(\begin{array}{cccccccccc}
v_{1, m_1-1}&\cdots&v_{11}&v_{2, m_2-1}&\cdots&v_{21}&\cdots&v_{d,
m_d-1}&\cdots&v_{d1}\\u_{1m_1}&\cdots&u_{12}&u_{2m_2}&\cdots&u_{22}&\cdots&u_{dm_d}&\cdots&u_{d2}\end{array}\right)
_{sorted}\\&\xrightarrow{\text{RSK}}(\overline{P}^{'} ,
\overline{Q}^{'}).\end{align*}


 由于 $\left(\begin{array}{c}
a\\b\end{array}\right)=\left(\begin{array}{c}
b^{'}\\a^{'}\end{array}\right)_{sorted}$， 从而由对行数的归纳易知
$({\overline{P}}^{'}, \overline{Q}^{'})=(\overline{Q},
\overline{P})$。 \qed





% \bibliographystyle{cfcbook}
\begin{thebibliography}{99}



\bibitem{Sagan}
B. Sagan, The Symmetric Group, second ed. Graduate Texts in
Mathematics 203, Springer-Verlag, New York, 2001.


\bibitem{Stanley86}
R.P. Stanley, Enumerative Combinatorics, vol. 1. Wadsworth and
Brooks/Cole, Pacific Grove, CA, 1986; second printing, Cambridge
University Press, New York/Cambridge, 1996.

\bibitem{Stanley1999}
R.P. Stanley, Enumerative Combinatorics, vol. 2. Cambridge
University Press, New York/Cambridge, 1999.

\bibitem{SW}
D. Stanton and D. White, Constructive Combinatorics, Springer, New York (1986).


\end{thebibliography}





\end{document} 
