\chapter{排列}

排列的研究在组合数学中占有重要的地位。本章中我们就主要介绍一下排列这种组合结构，
包括它的计数，算法，其上的统计量以及与杨表的关系。

\section{集合的排列}% A 上的置换的组合性质}

给定某个含有不同的元素集合$S$，我们把它的元素排成一个线性序，使得每个元素恰好出现一次，
叫做该集合的一个排列 (permutation). 以$[n]$表示$n$个正整数构成的集合$\{1,2,\cdots,n\}$, 那么$[n]$上的一个排列可以看成是$[n]$到自身的
一个双射。则$[n]$上所有排列对于映射的复合构成一个群，称
为$[n]$上的置换群，记作$S_n$。此时对于一个排列，我们可以用一行$\pi=\pi_1\pi_2
\cdots \pi_n$来表示，其中$\pi_i$表示$i$的像。
我们首先来看一下$[n]$上的排列的个数。

\begin{thm}\label{perT1}
集合$[n]$的全部排列的个数为$n!=n\times (n-1) \times (n-2)\times \cdots \times 2\times 1$, 即$|S_n|=n!$.
\end{thm}

\pf 在构建$n$元素集得一个排列$\pi=\pi_1\pi_2 \cdots
\pi_n$时，我们有$n$种选择方法来放置第一个元素$\pi_1$,
即可以从$\{1,2,\ldots,n\}$中任意选。对于$\pi_2$，由于我们
要求排列中元素互不相同，所以$\pi_2$不能取已放在第一个位置上的元素，
这时$\pi_2$有 $n-1$种选择。以此类推，我们得到$\pi_3$有$n-2$种选择，
到了最后一个元素$\pi_n$, 由于前面已经被选掉了$n-1$个元素，
所以$\pi_n$只有唯一的一种选择方法。所以根据乘法原理，
我们可得$[n]$上的排列总共有$n!$个。 \qed


注意，为方便起见，我们令$0!=1$.

\begin{exa}
若$n=3$, 则集合$[3]$上的排列个数为$3!=6$. 它们分别为
\[ 1\,2\,3,~~ 1\,3\,2,~~2\,1\,3,~~2\,3\,1,~~ 3\,1\,2,~~ 3\,2\,1.\]
\end{exa}

令$r$为正整数，从含有$n$个元素的集合$S$中取出$r$个元素排成一个线性序，叫做一个$r$-排列。
我们用$P(n,r)$表示$n$个元素集合的$r$-排列的数目。如果$r>n$, 则$P(n,r)=0$.

\begin{thm}
对于正整数$n$和$r$, $r\leq n$, 有
\[ P(n,r)=n\times (n-1) \times (n-2)\times \cdots \times (n-r+1).\]
\end{thm}

\pf 同定理\ref{perT1}的证明方法，此时第一个位置有$n$种选择方法, 即可以从$S$中任意选一个。对于第二个位置，我们有
$n-1$种选择。以此类推，对于第$r$个位置，我们还剩有$n-r+1$种选择。
所以总共有$n\times (n-1) \times (n-2)\times \cdots \times (n-r+1)$个$r$-排列。 \qed

\begin{exa}
若$S=\{a,b,c\}$, 则集合$S$上的$1$-排列为
\[ a,~~b,~~c\]
$S$上的$2$-排列为
\[ ab,~~ac,~~ba,~~bc,~~ca,~~cb.\]
\end{exa}


\begin{exa}
在中国采用公历之前，人们长期用干支纪法来记年、月、日，如甲子年、丙寅年、戊辰年等。实际
上这里也包含了排列的思想。
在中国古代的历法中，甲、乙、丙、丁、戊、己、庚、辛、壬、癸被称为“十天干”。
子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥叫作“十二地支”。其中甲、丙、戊、庚、壬
为阳干，乙、丁、己、辛、癸为阴干。
子、寅、辰、午、申、戌为阳支，丑、卯、巳、未、酉、亥为阴支。
以一个天干和一个地支相配，排列起来，天干在前，地支在后，天干由甲起，
地支由子起，
阳干对阳支，阴干对阴支（阳干不配阴支，阴干不配阳支）
得到六十年一周期的甲子回圈。
称为“六十甲子”或“花甲子”。
\end{exa}

\section{排列的生成算法}
实际工作中有时要在计算机上对各种排列状态下出现的情况加以分析，下面介绍若干排列的
生成算法。

\subsection{递归法}
要生成一个$[n]$上的排列，我们可以从$[n-1]$上的排列，插入$n$而得。具体的说就是
给定$\pi=\pi_1\pi_2
\cdots \pi_{n-1}$, 我们可以把$n$插入$\pi_i$ $\leq n-1$ 前面而得到一个$[n]$上的排列$\pi_1\pi_2
\cdots n \pi_i \cdots \pi_{n-1}$, 或者插入到最后一个位置后面得到$\pi_1\pi_2
\cdots \pi_{n-1}n$. 由此递归关系，我们只要已知了小于$n$个数上的集合的排列，就能得出
具有$n$个元素的集合的排列。下面给出了在maple里实现的代码，感兴趣的同学可以自己尝试一下。
\\
> p:=proc(n)\\
> local i,j,k,T:\\
> option remember:\\
> if n<1 then return "Error input!":\\
> elif n=1 then p(n):=[[1]]:\\
> elif n>1 then\\
> T:=[]:\\
> for i from 1 to nops(p(n-1))\\
> do T:=[op(T),[seq(p(n-1)[i][k],k=1..n-1),n]]:\\
> for j from 2 to n-1\\
> do T:=[op(T),[seq(p(n-1)[i][k],k=1..j-1),n,seq(p(n-1)[i][k],k=j..n-1)]]:od:\\
> T:=[op(T),[n,seq(p(n-1)[i][k],k=1..n-1)]]: od:\\
> p(n):=T:\\
> fi:\\
> end:\\

这里我们给出的是集合$[n]$上的排列。例如，当$n=4$时，运行$p(4)$之后，我们就得到了
24个排列。

> p(4);

  [[1, 2, 3, 4], [1, 4, 2, 3], [1, 2, 4, 3], [4, 1, 2, 3],

        [1, 3, 2, 4], [1, 4, 3, 2], [1, 3, 4, 2], [4, 1, 3, 2],

        [3, 1, 2, 4], [3, 4, 1, 2], [3, 1, 4, 2], [4, 3, 1, 2],

        [2, 1, 3, 4], [2, 4, 1, 3], [2, 1, 4, 3], [4, 2, 1, 3],

        [2, 3, 1, 4], [2, 4, 3, 1], [2, 3, 4, 1], [4, 2, 3, 1],

        [3, 2, 1, 4], [3, 4, 2, 1], [3, 2, 4, 1], [4, 3, 2, 1]]

\subsection{直接法}
下面我们给出直接生成所有排列的算法，由于不需要储存之前小于所求数字上的所有
排列，所以该算法的效率比较高。详细思想可见Stanton和White的书\cite{SW}. 以下是
直接生成排列的Maple程序。
\\
>PermutationList:=proc(n)\\
> local i,j,m,d,T,TINV,A,Done,res:
> if n=1 then return [1]; end if:  \\
> T:=[seq(i-1,i=1..n+2)]:TINV:=[seq(i+1,i=1..n)]:d:=[seq(-1,i=1..n)]:\\
> T[1]:=n+1:T[n+2]:=n+1:\\
> A:={seq(i,i=2..n)}:\\
> res:=[]:\\
>\\
> Done:=true:\\
> while Done do\\
>     res:=[op(res),T[2..n+1]]:\\
>     if nops(A)<>0 then\\
>         m:=op(nops(A),A):\\
>         j:=TINV[m]:\\
>         T[j]:=T[j+d[m]]:\\
>         T[j+d[m]]:=m:\\
>         TINV[m]:=TINV[m]+d[m]:\\
>         TINV[T[j]]:=j:\\
>         if m<T[j+2*d[m]] then\\
>            d[m]:=-1*d[m]:\\
>            A:=A minus {m}:\\
>         end if:\\
>         A:=A union {seq(i,i=m+1..n)}:\\
>     else\\
>         Done:=false:\\
>     end if:\\
> end do:\\
> return res;\\
> end:\\


例如，当$n=4$时，运行PermutationList(4)之后，我们就得到了
如下24个排列。

>PermutationList(4);

  [[1, 2, 3, 4], [1, 2, 4, 3], [1, 4, 2, 3], [4, 1, 2, 3],

        [4, 1, 3, 2], [1, 4, 3, 2], [1, 3, 4, 2], [1, 3, 2, 4],

        [3, 1, 2, 4], [3, 1, 4, 2], [3, 4, 1, 2], [4, 3, 1, 2],

        [4, 3, 2, 1], [3, 4, 2, 1], [3, 2, 4, 1], [3, 2, 1, 4],

        [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 3, 1], [4, 2, 3, 1],

        [4, 2, 1, 3], [2, 4, 1, 3], [2, 1, 4, 3], [2, 1, 3, 4]]

\section{基本统计量}% 上的置换上的一些统计量的定义和性质}

排列的各种统计量是组合数学研究的一个重要课题，对排列统计量的研究可以使我们
更清楚的了解排列的内部结构。下面我们就介绍一些在排列上十分熟知的统计量。

位置$i$($1\leqslant i<n$)称为是$\pi$的一个{下降位}(descent)
如果$\pi_i>\pi_{i+1}$；反之则称为$\pi$的{上升位}(acscent).
定义所有下降位构成的集合

$$\Des(\pi)=\{i|\pi_i>\pi_{i+1}\}$$
为$\pi$的下降集(descent set),
定义该集合的个数为$\des(\pi)=|\Des(\pi)|$为
$\pi$的下降数。由定义$n\notin \Des(\pi)$.
同时我们定义一个排列的主指标(major index)为
\[\maj(\pi)=\sum \limits_{i \in \Des(\pi)}i.\]

如果位置$i$满足$\pi_i>i$, 则称$i$是一个{胜位}(excedance), 若$i$满足
$\pi_i\geq i$, 则称$i$是{弱胜位}(weak excedance). 我们记 $\pi$
的所有胜位的个 数为 $\exc(\pi)$.

一对元素$(i,j)$
称为是一个{逆序}(inversion)，如果满足$i<j$且$\pi_i>\pi_j$, 称$\pi$的
所有逆序的个数为$\pi$的逆序数，记作$\inv(\pi)$.

对于排列$\pi=\pi_1\pi_2\cdots \pi_n$, 定义其逆为其作为映射的逆，即
$\pi^{-1}=\pi^{-1}(1)\pi^{-1}(2)\cdots \pi^{-1}(n)$;
定义其反为$\pi^r=\pi_n\pi_{n-1}\ldots\pi_1$; 定义
其补为$\pi^c=(n+1-\pi_1)(n+1-\pi_2)\cdots(n+1-\pi_n)$,
显然它们三个都是$S_n$上自然的一一映射。

\begin{exa}
对于$[5]$上的排列$\pi=43521$, 以上的统计量分别为：
$\Des(\pi)=\{1,3,4\}$, $\des(\pi)=3$, $\maj(\pi)=1+3+4=8$,
$\exc(\pi)=3$, $\inv(\pi)=7$.
\end{exa}

\subsection{下降数与胜位的等分布性质}
我们称两个统计量$u,v$在某个集合$S$上是{等分布的}(equidistribute)，
若对于任意的自然数$k$, 有
$\#\{x\in S|u(x)=k\}=\#\{x\in S|v(x)=k\}$.

\begin{thm} \label{exc_des}
$\exc$ 与 $\des$在$S_n$上是等分布的。
\end{thm}

一般而言，证明两个统计量的等分布性有两个主要的思路：
一个是组合证明，即寻找所在集合的一个到
自身的双射；另一个是代数证明，即证明二者有相同的生成函数。

\pf 组合证明：

在证明之前，先引入排列的另一种表示形式——圈表示。对于任意$x\in
[n]$, 考虑 序列$x,\pi(x),\pi^2(x),\ldots$,
最终一定形成一个圈（因为$\pi$是双射且$[n]$是有限集）。对所有的元素寻
找这样的圈，我们可以把排列$\pi$写成若干个不交圈的并的形式。
这种形式显然不是唯一的，首先，圈之间的顺
序可以任意，其次，圈内部的圈排列也有不同的表示。
为保证其唯一性，我们定义如下标准圈表示形式：

\begin{itemize}
   \item [a.]每个圈的最大元素放在首位；
   \item [b.]圈按照其最大元从小到大排列。
\end{itemize}


可以证明，以上的标准圈表示形式存在且唯一的。

对于任意一个排列$\pi\in S_n$，我们考虑其标准圈表示，
并将标准圈表示的圈去掉，这样就得到$[n]$上的一个新
的排列$\pi'$，可以证明$\pi\rightarrow \pi'$必然是$S_n$上的双射。
事实上，对于任意$\pi\in S_n$, 取其自左
向右极大元（即满足对于任意$j<i$, $\pi_j>\pi_i$的元素$\pi_i$）。
在相应位置加括号就可以得到上述映射的逆映射。

我们利用以上映射证明我们的结论，只需要证明对于任意的$\pi\in S_n$,
$\exc(\pi)=\des(\pi')$.
事实上，考虑$\pi$的补排列$\pi^c$的标准圈表示形式，
$\pi$的每一个胜位恰好对应到$(\pi^c)'$的一个下降位。命题得证。\qed

一般地，称与$\des$在$S_n$上等分布的统计量为Eulerian的.


\subsection{逆序数与主指标}

首先我们用代数的方法来给出逆序数的生成函数。

\begin{thm}
\begin{equation}
\sum_{\pi\in
S_n}q^{\inv(\pi)}=(1+q)(1+q+q^2)\cdots(1+q+q^2+\cdots+q^{n-1}).
\end{equation}
\end{thm}

\pf 对任意的 $\pi \in S_n$, 定义其对应的逆序表(inversion table)为
$I(\pi)=(a_1,a_2,\cdots,a_n)$,
其中$a_i$为在$i$左边且比$i$大的元素的个数。
例如 $\pi=417396285$, 则$I(\pi)=(1,5,2,0,4,2,0,1,0)$.
由定义容易看出
\[I(n)=\{(a_1,a_2,\cdots,a_n): 0\leq a_i \leq n-i\}=
[0,n-1]\times [0,n-2] \times [0,1]\times [0,n].\]
且$I(n)$与$S_n$是一一对应的。

因此从上面的分析可知
\begin{eqnarray*}
\sum_{\pi\in S_n}q^{\inv(\pi)}
&=&\sum_{a_1=0}^{n-1}\sum_{a_2=0}^{n-2}\cdots
\sum_{a_n=0}^{0}q^{a_1+a_2+\cdots+a_n}\\
&=& \sum_{a_1=0}^{n-1}q^{a_1}\sum_{a_2=0}^{n-2}q^{a_2} \cdots
\sum_{a_n=0}^{0}q^{a_n}\\
&=&(1+q)(1+q+q^2)\cdots(1+q+q^2+\cdots+q^{n-1}).
\end{eqnarray*}
\qed

下面是置换与其逆之间的逆序数的一个关系。
\begin{prop}
对任意的 $\pi \in S_n$, 我们有 $\inv(\pi)=\inv(\pi^{-1})$.
\end{prop}

逆序数的生成函数从它的定义中就很容易得到，然而另一个定义方式截然不同的统计量——
主指标却和它有着非常紧密的联系，下面的定理告诉我们，二者是同分布的。

\begin{thm}
\begin{equation}
\sum_{\pi\in S_n}q^{\inv(\pi)}=\sum_{\pi\in S_n}q^{\maj(\pi)}.
\end{equation}
\end{thm}

\pf
我们寻找$S_n$到自身的一个双射来证明它。下面我们就给出由
Foata给出的这个经典的双射，一般称为Foata双射。

双射$\varphi$是递归的定义的。对$w=w_1w_2\cdots w_n \in S_n$,
我们首先令$r_1=w_1$. 现在假设$r_k$($k\leq 1$)已经定义了，
则$r_{k+1}$的定义是这样的：

如果$r_k$的最后一个字母大于（或小于）$w_{k+1}$,
则我们就在$r_k$中每个大于（或小于）$w_{k+1}$ 的字母后面画一条竖线，
这样就把$r_k$中的元素分成了一些块，
然后我们对每个块中的字母向右循环移动
一位，此时每个块中的最后一个元素就变成该块中第一个元素了，
最后我们再把$w_{k+1}$接到变换后的序
列后面，就得到了$r_{k+1}$. 令$\varphi(w)=r_n$.

由$\varphi$的构造可知在每一步变换后都能保证
$\maj(w_1w_2\cdots w_k)=\inv(r_k)$.　

要说明$\varphi$是双射，我们只需给出其逆映射。
从$\varphi$的定义我们可以类似的定义$\varphi^{-1}$如下：

假设$\sigma=\varphi(w)$, 则$\varphi^{-1}$ 的定义为：
若$\sg_n>\sg_1$, 则在小于$\sg_n$的数字之前加一 条竖线，并且在$\sg_n$
的前面也加；若$\sg_n<\sg_1$,
则在大于$\sg_n$的数字之前加一条竖线，并且在 $\sg_n$
的前面也加。然后我们把每个块中的元素向左循环移动一位，
去掉竖线就得到了一个新的置换，此时
我们就把最后一个元素固定下来作为$\varphi^{-1}$的最后一个元素。
接下来用同样的方法确定最后第二个元
素，$n$步以后就得到了$\varphi^{-1}(\sg)$,
且有$\inv(\sg)=\maj(\varphi^{-1}(\sg)$. \qed


我们给出一个例子以便读者更好的理解。

\begin{exa}
若 $w=417396285$, 我们有：
\begin{eqnarray*}
r_1  &=& w_1=4;\\
r_2  &=& 4|1;\\
r_3  &=& 4|1|7;\\
r_4  &=& 4|71|3;\\
r_5  &=& 4|7|1|3|9;\\
r_6  &=& 74|913|6;\\
r_7  &=& 7|4|9|31|6|2;\\
r_8  &=& 7|4|39|1|6|2|8;\\
r_9  &=& 7|934|61|82|5.
\end{eqnarray*}
且 $\maj(w)=1+3+5+6+8=23, \inv(\varphi(w))=23$.
\end{exa}

一般地，与$\mathrm{maj}$在$S_n$上等分布的统计量称为Mohonian的。




\section{欧拉数}

欧拉(Euler)，瑞士数学家及自然科学家。1707年4月15日出生于瑞士的巴塞尔，1783\\年
9月18日于俄国彼得堡去逝。欧拉出生于牧师家庭，自幼受父亲的教育。
13岁时入读巴塞尔大学，15岁大学毕业，16岁获硕士学位。

欧拉是18世纪数学界最杰出的人物之一，
他不但为数学界作出贡献，更把数学推至几乎整个物理的领域。
他是数学史上最多产的数学家，平均每年写出八百多页的论文，
还写了大量的力学、分析学、几何学、变分法等
的课本，《无穷小分析引论》、《微分学原理》、《积分学原理》
等都成为数学中的经典著作。

欧拉对数学的研究如此广泛，因此在许多数学的分支中也可经常见
到以他的名字
命名的重要常数、公式和定理。 诸如：欧拉函数，欧拉数，
欧拉定理，欧拉常数等等。




\subsection{欧拉数的定义和性质}
设 $A(n,k)$ 为 $n$ 的所有置换中具有$k-1$个下降位的置换个数，我们称
$A(n,k)$ 为欧拉数 (Eulerian number).
本节我们就主要研究欧拉数的一些组合性质。在此之前，我们先给出 $n\leq
6$ 时欧拉数。

\begin{tabular}{c|c|c|c|c|c|c}
 $n \setminus k$    &1 &2 &3  &4  &5  &6\\
\hline $1$       &1  \\
\hline $2$       &1 &1 \\
\hline $3$       &1 &4 &1  \\
\hline $4$       &1 &11 &11  &1 \\
\hline $5$       &1 &26 &66  &26  &1 \\
\hline $6$       &1 &57 &302 &302 &57 &1
\end{tabular}

由欧拉数的组合意义，我们有下面的递推关系。

\begin{prop}\label{p1}
\begin{equation}
A(n,\,k)=kA(n-1,\, k)+(n-k+1)A(n-1,\,k-1)
\end{equation}
\end{prop}

\pf 给定一个 $n-1$ 长的且下降数为 $k-1$ 的排列，则我们把 $n$ 插入这
$k-1$ 个下降位的位置后面不会改变总的下降数的个数。显然如果把 $n$
插在最后一个位置也不会改变下降数的个数。如果在非下降位的后面插入
$n$, 则会使下降位增加一个。所以我们有 $A(n,\,k)=kA(n-1,\,
k)+(n-k+1)A(n-1,\,k-1).$ \qed

由上面的递推关系，我们很容易得到 $A(n,k)$ 的对称性。
\begin{prop}
\begin{equation}
A(n,k+1)=A(n,n-k).
\end{equation}
\end{prop}

当然从组合的观点，我们也可以这样而得。设 $n$ 的置换 $p=p_{1}p_{2}
\cdots p_n$有 $k$ 个下降数，则它的转置 $p^r=p_{n}p_{n-1}\cdots p_1$
有 $n-k-1$ 个降序数。由 $p$ 和 $p^r$ 的一一对应可得。

由\ref{exc_des}知，$\exc$与$\des$是等分布的，所以我们有。
\begin{prop}
在 $[n]$ 的所有置换中具有 $k-1$ 个胜位的置换个数为$A(n,k)$.
\end{prop}


\subsection{与欧拉数有关的等式}
由欧拉数的组合意义，我们还可以得到一些特殊的具有组合意义的式子。
\begin{thm}\label{t1}(\cite{Graham1994})
令 $A(0,0)=1$, 且当 $n>0$ 时，令 $A(n,0)=0$. 则对于所有非负整数 $n$
和实数 $x$ 满足如下等式
\begin{equation}\label{sm}
x^n=\sum_{k=0}^{n}A(n,k){x+n-k \choose n}
\end{equation}
\end{thm}

直接比较 \eqref{Ant}两边$k^n$的系数，很显然定理成立，
这里我们给出它的一个组合证明。定理两边都是关于$t$的$n$次多项式，
我们只需证明它对于$n+1$个不相等的实数成立即可。
这里，我们证明其对于任意正整数成立。

\pf 我们先假设$x$是一个正整数.则等式左边代表的是长度为 $n$
的，且每个分量取自集合 $[x]$
的序列个数.则我们只需说明等式右边也是计算的这种序列的个数。令
$a=a_{1}a_{2}\cdots a_n$
为任意一个这样的序列,重新排列$a$中元素的顺序使其非递降得
$a'=a_{i_{1}}\leq
a_{i_{2}}\leq \cdots \leq a_{i_{n}}$.
如果是相同的数字则在$a'$中的顺序是其在按照它们在$a$中的下
标递增的顺序排列.则$i=i_{1}i_{2}\cdots
i_{n}$ 为$n$ 的由 $a$ 唯一决定的置换，$i_{k}$
代表了$a$中第$i_{k}$大的数字所在的位置.例如 $a=3~1~1~2~4~3$,
重排后得 $a'=1~1~2~3~3~4$,对应的置换为 $i=2~3~4~1~6~5$.
\\
如果我们能说明每一个具有 $k-1$ 个下降数的置换 $i$ 是恰好从 $x+n-k$个
序列 $a$ 而得到的,则我们就完成了证明。
\\
很显然如果 $a_{i_{j}}=a_{i_{j+1}}$, 那么 $i_{j}<i_{j+1}$。
对应的，如果 $j$ 是置换 $p(a)=i_{1}i_{2}\cdots i_{n}$
的一个下降数，则 $a_{i_{j}}<a_{i_{j+1}}$.这就意味着只要 $j$
是一个下降数则序列 $a'$
在此位置是严格递增的。我们可以在上面的例子中验证一下。$i$ 在位置
$3,5$ 是 下降的，确实 $a'$
在这些位置上是严格递增的。那么有多少个序列 $a$ 能得到置换
$i=2~3~4~1~6~5$ 呢？由前面的分析可得，$a$ 中元素必须满足$$1\leq
a_{2}\leq a_{3} \leq a_{4} < a_{1} \leq a_6 <a_5 \leq x
$$严格的不等号是在第三个和第五个位置.上面的不等式链等价为
$$1\leq a_{2}< a_{3}+1
<a_{4}+2 < a_{1}+2 <a_6 +3 <a_5+3 \leq x$$ 因此这种序列的个数为
 ${x+3 \choose 6}$.
 同样的方法，对于任意的 $n$ 和具有 $k-1$ 个下降数的置换 $i$,
 我们得到 $n$ 的具有 $k-1$ 个下降数的置换可从
${x+(n-1)-(k-1)\choose n} $=${x+n-k \choose n}$ 个序列中得到.
\\如果 $x$ 不是一个正整数，由于等式两边都可以看作是关于变量 $x$
的多项式，而它们在无穷多个数值上取值相同，所以它们必须是本身是相等的。\qed


利用上述定理，我们可以讨论正整数前$n$项和的方幂求和的问题，
我们有如下结论：

\begin{prop}
\begin{align}
\sum_{x=1}^mx^n=\sum_{k=1}^{n}A(n,k){k+m\choose n+1}.
\end{align}
\end{prop}

\pf 首先，利用欧拉数的对称性，将\eqref{sm}进行化简。

当$n>0$时 \[t^n=\sum_{k=1}^{n}A(n,k){t+n-k \choose
n}=\sum_{k=1}^{n}A(n,n+1-k){t+n-k \choose
n}=\sum_{k=0}^{n-1}A(n,k+1){t+k \choose n}
\]
上式两边对$t$求和，有
\begin{align*}
\sum_{t=1}^mt^n &=\sum_{k=0}^{n-1}A(n,k+1)\sum_{t=1}^m{t+k \choose n}\\
                &=\sum_{k=0}^{n-1}A(n,k+1)\sum_{t=1}^m \left({t+k+1\choose n+1}-{t+k\choose n+1}\right)\\
                &=\sum_{k=0}^{n-1}A(n,k+1){m+k+1\choose n+1}\\
                &=\sum_{k=1}^{n}A(n,k){m+k\choose n+1}
\end{align*}
\qed



\begin{coro}
\begin{equation}
[x]^n=\sum_{k=0}^{n}A(n,k){x+k-1\choose n}.
\end{equation}
\end{coro}
\pf
 在定理\ref{t1}中用 $-x$ 代替 $x$,我们得
 $$x^n(-1)^n=\sum_{k=0}^{n}A(n,k){-x+n-k\choose n}.$$
 注意到 ${-x+n-k \choose n}$=$\frac{(-x+n-k)(-x+n-k-1)\cdots
(-x+1-k)}{n!}=(-1)^n{x+k-1 \choose
 n}$. 对照这两个等式就得到了结论。\qed

\begin{thm}
对于所有满足 $k\leq n$ 的非负整数 $n,k$, 有
\begin{equation}
A(n,k)=\sum_{i=0}^{k}(-1)^i{n+1 \choose i}(k-i)^n
\end{equation}
\end{thm}

\pf {组合证明}\\
我们先写下 $k-1$ 个竖线,这样就产生了 $k$ 个分间。把 $[n]$
中的每个元素放入任意一个分间内，有 $k^n$
种方法。然后对每个分间中的数字按递增的顺序排列。例如 $k=4,n=9$



那么其中的一个就可以为 $$237||19|4568.$$
忽虑掉那些竖线我们就得到了一个至多有 $k-1$
个下降数的置换(在上例中就是 $2~3~7~1~9~4~5~6~8$).
\\我们需注意以下几种情况:
可能会有空的分间(即分间里面没有放数字);或者相邻的分间之间没有下降数。由此我们就称一个竖线是"多余的"，如果
\\(a)
去掉它仍能得到一个符合规定的排列(即在每个分间中的数字是递增的顺序)。例如$4|12|3$中的第二个竖线。
\\(b)此竖线紧接着前面一个竖线(即有空的分间)。例如$2|35||614$中的第三个竖线。
我们的目标是计算没有"多余的竖线"的排列个数，因为这样的排列是与具有$k-1$个下降数的置换一一对应的。
我们利用容斥原理来计算，令$B_i$为至少有$i$个多余的竖线的排列数,$B$为没有多余的竖线的排列数，则
$$
B=k^n-B_1+B_2-B_3+\cdots +(-1)^nB_n.
$$
现在我们来计算这些 $B_i$. $B_1$
指的是至少有一个多余的竖线的排列，我们可以这样得到。先写下 $k-2$
个竖线，再把 $[n]$ 中的数字放入这 $k-1$ 个分间中，然后把一个多余的
竖线插入任意一个数字的左边，或放在末尾，共有 $n+1$
种方法，也就是$B_1={n+1 \choose 1}(k-1)^n$.
类似地，我们可得$B_2={n+1 \choose 2}(k-2)^n$,
这时我们是有$k-2$个分间，再把两个多余的竖线插入。继续这种方法得$$B_i={n+1
\choose i}(k-i)^n$$把这些式子代人 $B$
中就得到了所要证的等式的右边.\qed


\pf {代数证明}\\
 对欧拉多项式 $A_n(x)=\sum\limits^n_{k=1}A(n,k)x^k,$
我们有(见欧拉多项式那节)
$$\sum\limits^{\infty}_{k=1}k^nx^k=\frac{A_n(x)}{(1-x)^{n+1}}.$$
前面已经给出了它的组合证明。由上式可得$$(1-x)^{n+1}\sum\limits^{\infty}_{k=1}k^nx^k=A_n(x).$$
比较两边系数便可得证。\qed

下面我们来看一下欧拉数和第二类 Stirling 数之间的关系。第二类
Stirling 数 $S(n,k)$ 是指把集合 $\{1,2,\cdots,n\}$ 分成 $k$
个互不相交的无序块并的个数。

\begin{thm}
对于任意的正整数 $n,r$, 有
\begin{equation}
S(n,r)=\frac{1}{r!}\sum_{k=1}^{r}A(n,k){n-k\choose r-k}.
\end{equation}
\end{thm}

\pf{组合证明}
 等式两边同乘以
$r!$ 得, $$r!S(n,r)=\sum_{k=1}^{r}A(n,k){n-k\choose r-k}$$
显然左边代表的是集合 $[n]$ 的有序 $r$
划分。我们只要说明右边也是计算的同样的东西。对于 $[n]$ 的具有 $k-1$
个下降数的置换，就产生了 $k$ 个递增的字串，这恰好对应了 把集合 $[n]$
分成 $k$ 个部分。如果 $k=r$, 那么就是我们所要求的。如果 $k<r$,
我们就需要把一些递增字串拆开成若干个更小的串(保持
原来数字的顺序不变)，从而能到 $r$ 个递增字串。现在我们已经有了 $k$
个分块，我们还必须增加 $r-k$ 个块。$n$ 个元素的置换除了首末位置共有
$n-1$ 个空隙(相邻两个数字之间)，
只要我们不在下降数的位置,就可以把串分成更小的串，这样共有$A(n,k){n-k\choose
r-k}$ 种方法。
\\由上面的方法我们得到了 $\sum_{k=1}^{r}A(n,k){n-k\choose
r-k}$ 个 $[n]$ 的有序 $r$
分划。显然这种分划可由置换唯一决定。反之，给定一个$[n]$的分划,在每个块中的元素按递增的顺序排列，那么一个有序划分，从左到右读就得到了一个
至多具有$r$个递增字串的置换。\qed

\begin{thm}
对于任意的正整数$n,k$,有
\begin{equation}
A(n,k)=\sum_{r=1}^{k}S(n,r)r!{n-r\choose k-r}(-1)^{k-r}.
\end{equation}
\end{thm}

\pf{代数证明}
由上面的性质把$S(n,r)=\frac{1}{r!}\sum_{k=1}^{r}A(n,k){n-k\choose
r-k}$代人要证式子的右边得，
$$\sum_{r=1}^{k}S(n,r)r!{n-r\choose k-r}(-1)^{k-r}=\sum_{r=1}^{k}(-1)^{k-r}{n-r\choose k-r}\sum_{i=1}^{r}A(n,i){n-i\choose
r-i}$$ 改变求和顺序得
$$\sum_{r=1}^{k}S(n,r)r!{n-r\choose k-r}(-1)^{k-r}=\sum_{i=1}^{r}A(n,i){n-i\choose r-i}\sum_{r=1}^{k}(-1)^{k-r}{n-r\choose
k-r}$$
此等式的左边就是我们要证明的式子的右边，所以我们只要说明上式的右边等于$A(n,k)$.
显然上式中$A(n,k)$前的系数为${n-k\choose k-k}=1$,
所以我们能证明对于$i<k$,$A(n,i)$的系数为零就完成了证明。注意到，如果$r<i$,就有${n-i\choose
r-i}=0$, 则对任意的$i<k$, 我们有
$$\sum_{r=i}^{k}{n-i\choose r-i}{n-r\choose k-r}(-1)^{k-r}=\sum_{r=i}^{k}{n-i\choose r-i}{k-n-1\choose k-r}={k-i-1\choose k-i}=0$$
最后第二个等号是由Cauchy's convolution formula \footnote{[Cauchy's
convolution formula] 设$x,y$为实数,$z$为正整数,则有${x+y\choose
z}=\sum_{d=0}^{z}{x\choose d}{y\choose z-d}$}而得到的。\qed






\section{欧拉多项式}
由下降数或胜位出发，我们定义
$$A_n(t)=\sum_{\pi\in S_n}t^{1+\des(\pi)}=
\sum_{\pi\in S_n}t^{1+\exc(\pi)}$$ 为$[n]$上的欧拉多项式(Eulerian
polynomial). 由此定义，则 $A_n(t)$中$t^{k}$的系数为欧拉数$A(n,k)$.
所以欧拉多项式也可写为 \[A_n(t)=\sum_{k\geq 1}A(n,k)t^k,\,n\geq1.\]

特别地，定义$A_0(t)=1$。
本节我们主要研究欧拉多项式的一些基本的性质。在此之前，我们先给出$n\leq
6$时的欧拉多项式。
\begin{align*}
A_1(t) &=t, \\[5pt]
A_2(t) &=t+t^2, \\[5pt]
A_3(t) &=t+4t^2+t^3, \\[5pt]
A_4(t) &=t+11t^2+11t^3+t^4,\\[5pt]
A_5(t) &=t+26t^2+66t^3+26t^4+t^5, \\[5pt]
A_6(t) &=t+57t^2+302t^3+302t^4+57t^5+t^6
\end{align*}

\begin{prop}\label{epd}
欧拉多项式满足下面的微分方程
\begin{equation}
A_{n+1}(t)=t(1-t)A_n'(t)+(n+1)tA_n(t).
\end{equation}
\end{prop}
\pf 由递推关系容易得到
\[
\sum_{k}A(n+1,k)t^k=\sum_{k}kA(n,k)t^k+(n+1)\sum_kA(n,k-1)t^k-(k-1)\sum_{k}a(n,k-1)t^k.\]
由此可得
\[A_{n+1}(t)=tA_n'(t)+t(n+1)A_n(t)-t^2A_n'(t).\]
整理一下上式即可得结论。\qed


由此微分方程，我们可以容易地得到下面这个等式。

\begin{prop}\label{pELdxs}
\begin{equation}
\sum\limits^{\infty}_{k=1}k^nx^k=\frac{A_n(x)}{(1-x)^{n+1}}.
\end{equation}
\end{prop}
\pf 我们利用归纳法来证明。\\
当 $n=1$ 时，左边=
$\sum\limits^{\infty}_{k=1}kx^k=x\frac{1}{1-x}'=\frac{x}{(1-x)^2}.$=右边。\\
假设 $n$ 时也成立，我们来看 $n+1$ 的情况。 由
\[  \sum\limits^{\infty}_{k=1}k^nx^k=\frac{A_n(x)}{(1-x)^{n+1}}.   \]
对上式两边 $x$ 进行微分，得
\[
\sum\limits^{\infty}_{k=1}k^{n+1}x^{k-1}=\frac{(1-x)A_n'(x)+(n+1)A_n(x)}{(1-x)^{n+2}}.\]
要证　\[
\sum\limits^{\infty}_{k=1}k^{n+1}x^k=\frac{A_{n+1}(x)}{(1-x)^{n+2}},\]
则相当于只需证
\[A_{n+1}(x)=x(1-x)A_n(x)+(n+1)xA_n(x).\]
而由性质 \eqref{epd} 上式成立。　\qed




现在我们进一步研究欧拉多项式的指数生成函数。

\begin{thm} \label{ec}
令 $$A(x)=\sum_{n\geq0}A_n(t)\frac{x^n}{n!},$$ 则 $A(x)$ 满足
\begin{equation}
A'(x)=(A(x)-1)A(x)+tA(x).
\end{equation}
\end{thm}
\pf
我们从生成函数的角度来考虑。假定每个排列的降序位包含最后一位，则相应的生成函数仍是
$A(x).$ $A'(x)$
表示在排列中去掉最大元后所得到的排列对应的生成函数。不妨设
$\pi=\pi_1(n+1)\pi_2=a_1a_2\cdots a_i(n+1)a_{i+2}\cdots a_{n+1}\in
S_{n+1},\ 0\leq i\leq n.$

下面分析 $\pi$ 去掉 $n+1$ 后的结构。

如果 $i=0,$ 即 $\pi_1=\emptyset,$ 而 $\pi_2=\emptyset$ 或者
$\pi_2\neq \emptyset.$ 此时，在 $\pi$ 中去掉 $n+1$
后，所得排列降序数减少 $1,$ 所以 $\pi_1=\emptyset$
时，对应生成函数为 $tA(x);$ 如果 $1\leq i\leq n,$ 即 $\pi_1\neq
\emptyset,$ 设 $\des(\pi_1)=k_1,\,\des(\pi_2)=k_2,$ 则 $\pi$ 去掉
$n+1$ 后，所得的两个排列的降序数之和为 $k_1+k_2,$ 而原排列降序中
$a_i(n+1)$ 不对应一个降序，但 $(n+1)a_{i+2}$
一定对应一个降序，即原排列降序数为
$\left(k_1-1\right)+1+k_2=k_1+k_2,$ 则 $\pi_1\neq \emptyset$
时，对应生成函数为 $(A(x)-1)A(x).$

所以有 $$A'(x)=(A(x)-1)A(x)+tA(x).$$ \qed

\begin{coro}
$A_n(t)$ 的生成函数为
$$A(x)=\sum_{n\geq
0}A_n(t)\frac{x^n}{n!}=\frac{1-t}{1-te^{(1-t)x}}.$$
\end{coro}
\pf 根据关系式 \eqref{ec}，解如下微分方程， \allowdisplaybreaks
\begin{align*}\frac{d A}{(A-1)A+tA}&=d x,\\[5pt]
\frac{1}{t-1}\left(\frac{1}{A}-\frac{1}{A-1+t}\right)d A&=dx,\\[5pt]
 d\ln\frac{A}{A-1+t}&=(t-1)dx,\\[5pt]
\frac{A}{A-1+t}&=ce^{(t-1)x},
\end{align*}其中 $c$ 为常数，由初值 $A(0)=1,$ 得到 $c=\frac{1}{t},$
所以 $$A(x)=\frac{1-t}{1-te^{(1-t)x}}.$$ \qed

将生成函数展开为$x$和$t$的幂级数，可得
\begin{equation}\label{Ant}
A_n(t)=(1-t)^{n+1}\sum_{k\geq1}k^nt^k (n\geq1).
\end{equation}
即给出了性质\ref{pELdxs}的另一个证明。




下面我们讨论一下欧拉多项式的根的特点，首先我们给出一些关于根的特点的定义。

设 $f$ 是一个度为 $n$ 的，且根全为实数的多项式，定义
$\mathrm{roots}(f)=\left(a_{1},\ldots,\,a_{n}\right),$ 其中
$a_{1}\leqslant a_{2}\leqslant \cdots \leqslant a_{n}$ 为 $f(x)=0$
的根。(注意：如果我们写 $\mathrm{roots}(f)$ 的话，则已假定 $f$
的根全为实根)。

 \begin{defi} 给定多项式 $f,\,g,$
设 $\mathrm{roots}(f)=\left(a_{1},\ldots,\,a_{n}\right),\,
\mathrm{roots}(g)=\left(b_{1},\ldots,\, b_{n}\right),$ 称 $f,\,g$
是严格交错的，如果它们的根满足以下四种关系之一：
\begin{align*}
 a_{1}&<b_{1}<a_{2}<b_{2}< \cdots <a_{n}<b_{n};\\[5pt]
 b_{1}&<a_{1}<b_{2}< a_{2}< \cdots <b_{n};\\[5pt]
 b_{1}&<a_{1}<b_{2}<a_{2}< \cdots <b_{n}<a_{n};\\[5pt]
 a_{1}&<b_{1}<a_{2}< b_{2}< \cdots <a_{n};
\end{align*}
当把不等号 $<$换成$\leq$ 就称 $f,\,g$
是交错的。显然，如果两个多项式交错，则它们的度至多相差 $1$.
\end{defi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exa}
Eulerian多项式 $A_{3}(t)$ 和 $A_{4}(t)$ 是交错的。因为
\begin{align*}
A_3(t) &=t+4t^2+t^3 \\
A_4(t) &=t+11t^2+11t^3+t^4.
\end{align*}
所以$\roots\left(A_{3}(t)\right)=\left(-2-\sqrt{3},\,-2+\sqrt{3},\,0\right),\,
\roots\left(A_{4}(t)\right)=\left(-5-2\sqrt{6},\,-1,\,-5+2\sqrt{6},\,0\right).$

显然它们的根满足定义中的关系之一，所以这两个多项式是交错的。
\end{exa}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
为了叙述的方便，我们给出符号函数的定义。
 \begin{defi}
定义在实数集上的符号函数 $\sgn(x)$ 为：
$$ \sgn(x)=\left\{ \begin{array}{ll}
+1, \quad &\textrm{if $x>0,$}\\[5pt]
0 , \quad &\textrm{if $x=0,$}\\[5pt]
-1,  \quad &\textrm{if $x<0.$}
\end{array}\right.
$$
 \end{defi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \begin{thm}
对于任意给定的 $n,$ 欧拉多项式 $A_{n}(t)=\sum
_{k=1}^{n}A(n,\,k)t^{k}$ 的根全是实根，并且 $A_{n-1}(t)$ 和
$A_{n}(t)$ 是交错的。
\end{thm}

\pf 令$B_n(t)={A_n(t)\over(1-t)^{n+1}}$，由\eqref{Ant}，有
$${d\over dt}B_{n-1}(t)={d\over dt}\sum_{k\geq1}k^{n-1}t^k={1\over t}B_n(t)
$$整理得，
$$B_n(t)=t{d\over dt}B_{n-1}(t)
$$
补充定义$A_0(t)=t,$ 对于 $n\geqslant 1,$ 有
\begin{equation}\label{dt}
A_{n}(t)=t(1-t)^{n+1}\frac{d}{dt}(1-t)^{-n}A_{n-1}(t)
\end{equation}

下面我们用归纳法来证明欧拉多项式的根全为实根。当 $n=0$
时，欧拉多项式 $A_0(t)=t$ 的根为 $t=0.$

假设 $A_{n-1}(t)$ 有 $n-1$ 个不同的实根，其中有一个为 $t=0,$
其它全为负根。

从 $A_{n}(t)$ 与 $A_{n-1}(t)$ 的微分关系中，运用罗尔中值定理可知，在
$A_{n-1} (t)$ 的每两个相邻根之间必有一个 $A_{n}(t)$ 的根，而显然 $0$
也是一个根，这样我们就找到了 $A_{n}(t)$ 的 $n- 1$
个根。由于虚根是成对出现的，所以最后一个根也是实根。要证明 $A_{n-1}
(t)$ 和$A_{n}(t)$ 是交错的，只要说明这个根比 $A_{n-1} (t)$
的最小的那个根还要小。

设
$\roots\left(A_{n-1}(t)\right)=\left(r_{1},\,r_2,\ldots,\,r_{n-1}\right),$
则 $\sgn (A_{n-1}'(r_k))=(-1)^k,$ 因为 $A_{n-1}(t)'$
的首项系数为正的。除了 $r_1=0,$ 其余根均为负的，由\eqref{dt}式得
$\sgn (A_{n}(r_k))=(-1)^k,$ 因为 $A_{n}(t)$ 的首项系数也为正，所以
$\sgn (A_{n}(+\infty))=+1,\,  \sgn (A_{n}(-\infty))=(-1)^{n}.$
由此可知 $A_{n}(t)$ 必有一个根在区间 $(-\infty,\,r_{n-1})$ 上，所以
$A_{n-1}(t)$ 和 $A_{n}(t)$ 是交错的。\qed




\section{排列与杨表的对应}

\subsection{杨表}
杨表(Young tableau)是由杨（R.A.
Young）在1901年研究不变量理论时引入的，它在组合数学、群表示论、数学物理
等领域中都有重要应用。通常情况下，杨表是指定义在
杨图上的半标准杨表。

给定一个整数分拆$\lambda=(\lambda_1,\lambda_2,
\ldots,\lambda_k)$，与$\lambda$对应的
杨图(Young Diagram)定义为平面上一些左对齐的$k$行方块的集合，
使得第$i$行恰有$\lambda_i$个方块。例如，分拆$(4,2,1)$对应的杨图为
\begin{figure}[h]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}
\end{picture}
\end{center}
\end{figure}

在$\lambda$对应的杨图中，用正整数填充图中的每个方块得到一个阵列$T$，
若其每行递增每列严格递增，则称$T$为具有形状$\lambda$的
半标准杨表SSYT（semistandard Young
tableau），并记$\mathrm{sh}(T)=\lambda$。如果$T$中含有$\alpha_i$个$i$，那么称$(\alpha_1,\alpha_2,\ldots)$为
$T$的 类型（type）。例如，下面半标准杨表的类型为$(1,2,2,1,1)$。
\begin{figure}[ht]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}

 \put(4,22){1}  \put(14,22){2}
\put(24,22){3}\put(34,22){3} \put(4,12){2}
 \put(14,12){5}
\put(4,2){4}
\end{picture}
\end{center}
\end{figure}

设$\lambda$是$n$的一个分拆。
若用${1,2,\ldots,n}$填充$\lambda$对应的杨图使得每个数字恰好出现一次，
并且每行每列递增，则称这样的阵列为具有形状$\lambda$的
标准杨表SYT（standard Young tableau）。
例如下图是一个形状为$(4,2,1)$的标准杨表。

\begin{figure}[ht]
\setlength{\unitlength}{0.5mm}
\begin{center}
\begin{picture}(50,30)
\put(0,30){\line(1,0){40}}\put(0,20){\line(1,0){40}}
\put(0,20){\line(1,0){20}}\put(0,10){\line(1,0){20}}
\put(0,0){\line(1,0){10}}\put(0,0){\line(0,1){30}}
\put(10,0){\line(0,1){30}}\put(20,30){\line(0,-1){20}}
\put(30,30){\line(0,-1){10}}\put(40,30){\line(0,-1){10}}
\put(4,22){1}  \put(14,22){3} \put(24,22){6}\put(34,22){7}
\put(4,12){2}
 \put(14,12){5}
\put(4,2){4}
\end{picture}
\end{center}
\end{figure}


\subsection{RSK算法}

RSK算法是根据罗宾森 （G.B. Robinson），森斯特德（C.E.
Schensted），克努斯 （D.E. Knuth）
的名字命名的，它是对称函数领域里一个优美的组合对应。
RSK算法最初是在试图证明
李特尔伍德-里查德森法则时作为一个工具由罗宾森于1938年提出的，
后又被森斯特德于1961年在研究排列的最长递增和递降子序列时重新发现，而
克努斯于1970年将RSK算法从排列推广到了广义置换（generalized
permutaition）上。
关于更多的RSK算法的介绍可见Stanley书\cite{Stanley1999}.


RSK算法的基本运算是行插入算法，即把整数$i$插入行递增和列严格递增的一个
表格$T$中，即$T$是一个半标准杨表。
把$i$插入$T$后，我们就得到了一个新的表格，记为$T\leftarrow i$,
仍旧满足行递增和列严格递增。如果$S$是$T$中的值组成的集合，则$S \cup
\{i\}$就是$T\leftarrow
i$中的值组成的集合。现在我们就来介绍如何递归地定义$T\leftarrow i$.

\begin{itemize}
  \item 如果$T$的第一行是空行或者第一行上的最大值小于$i$,
  则把$i$插入到第一行的末尾。
  \item 否则，找到第一行中第一个满足大于$i$的数字$j$, 用$i$取代$j$,
  然后用同样的原则把$j$插入第二行。继续这种算法，直到某个数插入
  某一行的末尾即停止(或者在原来的表格中新增了一行)。
\end{itemize}

同时，我们可以定义与之对应的$insertion\
 path$，即$T$中所有的那些在这些行插入的过程中改变过的位置的集合，
 记为$I(T\leftarrow i)$。

\begin{exa}
下面是相应的一个简单的例子：
\end{exa}

\begin{picture}(250,120)(-20,5)
\put(45,110){i=5} \put(0,70){T=} \put(30,90){2} \put(45,90){3}
\put(60,90){3} \put(75,90){6} \put(90,90){7} \put(30,75){4}
\put(45,75){5} \put(60,75){5} \put(75,75){7} \put(30,60){6}
\put(45,60){6} \put(60,60){8} \put(30,45){9}
\put(140,70){$T\leftarrow i=$} \put(200,90){2} \put(215,90){3}
\put(230,90){3} \put(245,90){\textbf{5}} \put(260,90){7}
\put(200,75){4} \put(215,75){5} \put(230,75){5}
\put(245,75){\textbf{6}} \put(200,60){6} \put(215,60){6}
\put(230,60){\textbf{7}} \put(200,45){\textbf{8}}
\put(200,30){\textbf{9}} \put(0,10){$I(T\leftarrow i)= \{(1,4),
(2,4), (3,3), (4,1), (5,1)\}$}
\end{picture}

关于更多的RSK算法的介绍可见Sagan书\cite{Sagan}第三章
和Stanley书\cite{Stanley1999}第七章。

令$w=a_1a_2\cdots a_n \in S_n$, 令$\emptyset$为空表格。定义
\[ P_i=P_i(w)=(\cdots ((\emptyset \leftarrow a_1)\leftarrow a_2)
\leftarrow \cdots \leftarrow a_i).\]
也就是说，$P_i$是从空表格出发，依次插入$a_1,a_2,\ldots,a_i$而得的。
此时$P_i$可以看成是一个标准杨表，除了它的值可以为任意的不同整数，
而不是
仅仅限制为$1,2,\ldots,n$. 记$P=P(w)=P_n(w)$. 定义$Q_0=\emptyset$,
当$Q_{i-1}$确定好之后，定义$ Q_i=Q_i(w)$为是在$Q_{i-1}$中插入$i$,
使得$Q_i$和$P_i$具有相同的形状，且不改变$Q_{i-1}$中任何元素的位置和值。
记$Q=Q(w)=Q_n(w)$,
最后定义RSK算法作用在$w$上后的输出值为一对杨表$(P,Q)$, 记作$w
\xrightarrow[]{\text{RSK}}(P,Q)$.



例如，我们对排列$\pi=256384197$运用RSK算法，对应的$(P,Q)$可有如下过程生成。
\newpage
\begin{picture}(100,50)
\put(35,40){\line(1,0){15}}\put(35,40){\line(0,-1){15}}\put(35,25){\line(1,0){15}}\put(50,40){\line(0,-1){15}}
\put(40,29){2}\put(40,50){$P_i$}

\put(285,40){\line(1,0){15}}\put(285,40){\line(0,-1){15}}\put(285,25){\line(1,0){15}}\put(300,40){\line(0,-1){15}}
\put(290,29){1}\put(290,50){$Q_i$}

\put(28,0){\line(1,0){30}}\put(28,-15){\line(1,0){30}}\put(28,0){\line(0,-1){15}}\put(43,0){\line(0,-1){15}}\put(58,0){\line(0,-1){15}}
\put(33,-11){2}\put(48,-11){5}

\put(278,0){\line(1,0){30}}\put(278,-15){\line(1,0){30}}\put(278,0){\line(0,-1){15}}\put(293,0){\line(0,-1){15}}\put(308,0){\line(0,-1){15}}
\put(283,-11){1}\put(298,-11){2}

\put(20,-40){\line(1,0){45}} \put(20,-55){\line(1,0){45}}
\put(20,-40){\line(0,-1){15}}\put(35,-40){\line(0,-1){15}}\put(50,-40){\line(0,-1){15}}\put(65,-40){\line(0,-1){15}}
\put(25,-51){2}\put(40,-51){5}\put(55,-51){6}

\put(270,-40){\line(1,0){45}} \put(270,-55){\line(1,0){45}}
\put(270,-40){\line(0,-1){15}}\put(285,-40){\line(0,-1){15}}\put(300,-40){\line(0,-1){15}}\put(315,-40){\line(0,-1){15}}
\put(275,-51){1}\put(290,-51){2}\put(305,-51){3}

\put(20,-80){\line(1,0){45}} \put(20,-95){\line(1,0){45}}
\put(20,-110){\line(1,0){15}}\put(20,-80){\line(0,-1){30}}\put(35,-80){\line(0,-1){30}}\put(50,-80){\line(0,-1){15}}
\put(65,-80){\line(0,-1){15}}\put(25,-91){2}\put(40,-91){3}\put(55,-91){6}\put(25,-106){5}

\put(270,-80){\line(1,0){45}} \put(270,-95){\line(1,0){45}}
\put(270,-110){\line(1,0){15}}\put(270,-80){\line(0,-1){30}}\put(285,-80){\line(0,-1){30}}\put(300,-80){\line(0,-1){15}}
\put(315,-80){\line(0,-1){15}}\put(275,-91){1}\put(290,-91){2}\put(305,-91){3}\put(275,-106){4}

\put(13,-135){\line(1,0){60}}\put(13,-150){\line(1,0){60}}\put(13,-165){\line(1,0){15}}\put(13,-135){\line(0,-1){30}}
\put(28,-135){\line(0,-1){30}}\put(43,-135){\line(0,-1){15}}\put(58,-135){\line(0,-1){15}}\put(73,-135){\line(0,-1){15}}
\put(18,-146){2}\put(33,-146){3}\put(48,-146){6}\put(63,-146){8}\put(18,-161){5}

\put(263,-135){\line(1,0){60}}\put(263,-150){\line(1,0){60}}\put(263,-165){\line(1,0){15}}\put(263,-135){\line(0,-1){30}}
\put(278,-135){\line(0,-1){30}}\put(293,-135){\line(0,-1){15}}\put(308,-135){\line(0,-1){15}}\put(323,-135){\line(0,-1){15}}
\put(268,-146){1}\put(283,-146){2}\put(298,-146){3}\put(313,-146){5}\put(268,-161){4}

\put(13,-190){\line(1,0){60}}\put(13,-205){\line(1,0){60}}\put(13,-220){\line(1,0){30}}\put(13,-190){\line(0,-1){30}}
\put(28,-190){\line(0,-1){30}}\put(43,-190){\line(0,-1){30}}\put(58,-190){\line(0,-1){15}}\put(73,-190){\line(0,-1){15}}
\put(18,-201){2}\put(33,-201){3}\put(48,-201){4}\put(63,-201){8}\put(18,-216){5}\put(33,-216){6}

\put(263,-190){\line(1,0){60}}\put(263,-205){\line(1,0){60}}\put(263,-220){\line(1,0){30}}\put(263,-190){\line(0,-1){30}}
\put(278,-190){\line(0,-1){30}}\put(293,-190){\line(0,-1){30}}\put(308,-190){\line(0,-1){15}}\put(323,-190){\line(0,-1){15}}
\put(268,-201){1}\put(283,-201){2}\put(298,-201){3}\put(313,-201){5}\put(268,-216){4}\put(283,-216){6}
\end{picture}
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\


\begin{picture}(100,50)
\put(13,50){\line(1,0){60}}\put(13,35){\line(1,0){60}}\put(13,20){\line(1,0){30}}\put(13,5){\line(1,0){15}}
\put(13,50){\line(0,-1){45}}\put(28,50){\line(0,-1){45}}\put(43,50){\line(0,-1){30}}\put(58,50){\line(0,-1){15}}
\put(73,50){\line(0,-1){15}}\put(18,39){1}\put(33,39){3}\put(48,39){4}\put(63,39){8}\put(18,24){2}\put(33,24){6}\put(18,9){5}

\put(263,50){\line(1,0){60}}\put(263,35){\line(1,0){60}}\put(263,20){\line(1,0){30}}\put(263,5){\line(1,0){15}}
\put(263,50){\line(0,-1){45}}\put(278,50){\line(0,-1){45}}\put(293,50){\line(0,-1){30}}\put(308,50){\line(0,-1){15}}
\put(323,50){\line(0,-1){15}}\put(268,39){1}\put(283,39){2}\put(298,39){3}\put(313,39){5}\put(268,24){4}\put(283,24){6}\put(268,9){7}

\put(5,-20){\line(1,0){75}}\put(5,-35){\line(1,0){75}}\put(5,-50){\line(1,0){30}}\put(5,-65){\line(1,0){15}}
\put(5,-20){\line(0,-1){45}}\put(20,-20){\line(0,-1){45}}\put(35,-20){\line(0,-1){30}}\put(50,-20){\line(0,-1){15}}
\put(65,-20){\line(0,-1){15}}\put(80,-20){\line(0,-1){15}}\put(10,-31){1}\put(25,-31){3}\put(40,-31){4}\put(55,-31){8}
\put(70,-31){9}\put(10,-46){2}\put(25,-46){6}\put(10,-61){5}

\put(255,-20){\line(1,0){75}}\put(255,-35){\line(1,0){75}}\put(255,-50){\line(1,0){30}}\put(255,-65){\line(1,0){15}}
\put(255,-20){\line(0,-1){45}}\put(270,-20){\line(0,-1){45}}\put(285,-20){\line(0,-1){30}}\put(300,-20){\line(0,-1){15}}
\put(315,-20){\line(0,-1){15}}\put(330,-20){\line(0,-1){15}}\put(260,-31){1}\put(275,-31){2}\put(290,-31){3}\put(305,-31){5}
\put(320,-31){8}\put(260,-46){4}\put(275,-46){6}\put(260,-61){7}


\put(5,-90){\line(1,0){75}}\put(5,-105){\line(1,0){75}}\put(5,-120){\line(1,0){45}}\put(5,-135){\line(1,0){15}}
\put(5,-90){\line(0,-1){45}}\put(20,-90){\line(0,-1){45}}\put(35,-90){\line(0,-1){30}}\put(50,-90){\line(0,-1){30}}
\put(65,-90){\line(0,-1){15}}\put(80,-90){\line(0,-1){15}}
\put(10,-101){1}\put(25,-101){3}\put(40,-101){4}\put(55,-101){7}\put(70,-101){9}\put(10,-116){2}\put(25,-116){6}
\put(40,-116){8}\put(10,-131){5}

\put(255,-90){\line(1,0){75}}\put(255,-105){\line(1,0){75}}\put(255,-120){\line(1,0){45}}\put(255,-135){\line(1,0){15}}
\put(255,-90){\line(0,-1){45}}\put(270,-90){\line(0,-1){45}}\put(285,-90){\line(0,-1){30}}\put(300,-90){\line(0,-1){30}}
\put(315,-90){\line(0,-1){15}}\put(330,-90){\line(0,-1){15}}
\put(260,-101){1}\put(275,-101){2}\put(290,-101){3}\put(305,-101){5}\put(320,-101){8}\put(260,-116){4}\put(275,-116){6}
\put(290,-116){9}\put(260,-131){7}
\end{picture}
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
\begin{thm}
令$\mathcal{T}_{n}=\{(T_{1},
T_{2})|T_{1}$和$T_{2}$是两个形状均为$\lambda\mapsto
n$的标准杨表$\}$，则
RSK算法给出了$[n]$上的排列集合$S_n$和集合$\mathcal{T}_{n}$
之间的一一对应。
\end{thm}
\pf 记映射\[\varphi: S\mapsto \mathcal{T}_{n}, w=a_{1}a_{2}\cdots
a_{n}\mapsto (T_{1}, T_{2})\]为RSK算法后所对应的那个映射。

下面来考虑$\varphi^{-1}$。对任一$(P, Q)=(P(n), Q(n))\in
\mathcal{T}_{n}$，假定$Q_{rs}=n$，即$n$在$Q$的第$r$行第$s$列的位置。则令$Q(n-1)=Q(n)\setminus
n$。不难知道，$P_{rs}$是将$\pi_{n}$插入$P(n-1)$后对应的$insertion\
 path$中最后一个位置的元素。事实上，不难得到$P(n-1)\leftarrow \pi_{n}$的逆过程：$P_{rs}$一定是被$P$的第$r-1$
 行中最靠右的比$P_{rs}$小的元素不妨设为$P_{r-1, t}$挤入第$r$行的。因此，从$P$中移去$P_{rs}$所在的方格，将$P_{r-1, t}$
 用$P_{rs}$代换，然后继续将第$r-2$行中最靠右的比$P_{r-1, t}$小的元素用$P_{r-1, t}$代换，$\ldots$，最后，必然从$P$中挤出了某元素即为$\pi_{n}$。至此，我们由$(P(n), Q(n))$唯一得到了$(n,
\pi_{n})$和$(P(n-1),
Q(n-1))$，如此继续，最终可得置换$\left(\begin{array}{cccc}
1&2&\cdots&n\\\pi_1&\pi_2&\cdots&\pi_n\end{array}\right)$。\qed

如果$w \xrightarrow[]{\text{RSK}}(P,Q)$,
且$P,Q$具有相同的形状$\lambda$, 则我们称$w$具有形状$\lambda$,
记为$\lambda=\mathrm{sh}(w)$.
$\lambda$的共轭分拆$\lambda'=(\lambda_1',\lambda_2',\ldots)$,
其对应的表格是把$\lambda$的表格翻转而得。等价地说，$j$在$\lambda'$中出现
的次数为$\lambda_j-\lambda_{j+1}$.
记$l(\lambda)$为分拆$\lambda$中非零部分的个数，所以$l(\lambda)=\lambda_1'$.

$w$的一个递增子序列是指一个子序列$a_{i_1},a_{i_2},\ldots,a_{i_k}$满足
$a_{i_1}<a_{i_2}<\cdots<a_{i_k}$,
类似地可以定义递减子序列。例如，若$w=5\,6\,4\,2\,7\,1\,3$,
则$5\,6\,7$是一个递增子序列，$5\,4\,3$是一个递减子序列。令$\mathrm{is}(w)
 (\mathrm{ds}(w))$为$w$中的最长递增（递减）子序列的长度。对于如上的$w$, 我们
 有$\mathrm{is}(w) = 3$ (对应于$5\,6\,7$), $\mathrm{ds}(w) =
4$ (对应于序列$5\,4\,2\,1$或$6\,4\,2\,1$).
由RSK算法，我们可以发现$T_{1}$中第一行的方格总数即为$a=a_{1}a_{2}\cdots
a_{n}$的最长递增子列的长度；$T_{1}$中第一列的方格总数即为$a=a_{1}a_{2}\cdots
a_{n}$的最长递减子列的长度。所以我们可以得到以下关于
排列中的最长的递增或递减子序列的长度与对于杨表之间的
关系。
\begin{thm}
令$w \in S_n$, 且$\mathrm{sh}(w)=\lambda$, 则
\begin{eqnarray}
\mathrm{is}(w)&=&\lambda_1,\\
 \mathrm{ds}(w)&=&\lambda_1'.
\end{eqnarray}
\end{thm}


下面我们考虑置换$\pi$与其逆置换$\pi^{-1 }$在RSK算法下所对应的杨表
之间的相互关系。


\begin{thm} 若 $\pi\in S_n$ 并且
$\pi\xrightarrow{\text{RSK}}(P, Q)$，则对 $\pi$ 的逆 $\pi^{-1 }$，有
$\pi^{-1 }\xrightarrow{\text{RSK}}(Q, P)$。
\end{thm}

\pf 设 $\pi=\left(\begin{array}{cccc}
1&2&\cdots&n\\v_1&v_2&\cdots&v_n\end{array}\right)$=
$\left(\begin{array}{c}
u\\v\end{array}\right)$, $\pi^{-1 }=\left(\begin{array}{c}
v\\u\end{array}\right)_{sorted}$ (即适当排列使得
$\left(\begin{array}{c} v\\u\end{array}\right)_{sorted}$
中第一行元素递增)。按如下方式定义 inversion poset
$I=I\left(\begin{array}{c} u\\v\end{array}\right)$：

$\left(\begin{array}{c} u\\v\end{array}\right)$ 的每列定义为 $I$
中的每个点，若 $a<c, b<d$，则在 $I$ 中 $ab<cd$ (为方便起见，将
$\begin{array}{c} a\\b\end{array}$ 记为 $ab$)。

由 $I(A)$ 的定义容易得到下面的引理。


\begin{lem}  映射 $\varphi: I\left(\begin{array}{c}
u\\v\end{array}\right)\rightarrow I\left(\begin{array}{c}
v\\u\end{array}\right)$ \ \ $\varphi(ab)=ba$ 是
$I\left(\begin{array}{c} u\\v\end{array}\right)$ 到
$I\left(\begin{array}{c} v\\u\end{array}\right)$ 的同构。\end{lem}


定义 $I_1$ 是 $I$ 中最小元的集合，$I_2$ 是 $I-I_1$
中最小元的集合，$I_3$ 是 $I-I_1-I_2$
中最小元的集合，$\cdots$。注意，易知 $I_i$ 是 $I$
中的反链即它的元素可以记为：$(u_{i1}, v_{i1}), (u_{i2}, v_{i2}),
\ldots, (u_{in_i}, v_{in_i})$ 使得 $u_{i1}<u_{i2}<\cdots<u_{in_i}$
且
$v_{i1}>v_{i2}>\cdots>v_{in_i}(n_i=|I_i|)$。
我们假定以下反链中的元素都作如此标记。


\begin{lem}\label{ya}  若 $I_1, I_2, \ldots, I_d$ 是如上标记的 $I$ 的非空反链，则 $P$ 的第一行元素是 $v_{1n_1}v_{2n_2}\cdots
v_{dn_d}$，$Q$ 的第一行元素是 $u_{11}u_{21}\cdots u_{d1}$。并且，若
$(u_k, v_k)\in I_i$，则 $v_k$ 在 RSK 算法执行过程中被插入 $P(k-1)$
第一行的第 $i$ 个位置。
\end{lem}


\noindent {\bf{引理\ref{ya}的证明}} 通过对 $n$ 归纳来证此引理。$n=1$
时显然结果是平凡的。假设对 $n-1$ 时此引理成立，并且令
$\left(\begin{array}{c}
u\\v\end{array}\right)=\left(\begin{array}{cccc}
1&2&\cdots&n\\v_1&v_2&\cdots&v_n\end{array}\right)$，
$\left(\begin{array}{c}
\tilde{u}\\\tilde{v}\end{array}\right)=\left(\begin{array}{cccc}
1&2&\cdots&n-1\\v_1&v_2&\cdots&v_{n-1}\end{array}\right)$。 设
$(P(n-1), Q(n-1))$ 是插入 $v_1, \ldots, v_{n-1}$ 后所得到的
tableau，$I_i^{'} :=I_i\left(\begin{array}{c}
\tilde{u}\\\tilde{v}\end{array}\right)=\{(\tilde{u}_{i_1},
\tilde{v}_{i_1}),  (\tilde{u}_{i_2}, \tilde{v}_{i_2}), \ldots,
(\tilde{u}_{im_i}, \tilde{v}_{im_i})\},\\ 1\leq i\leq e(e=d-1$ 或
$e=d)$。由归纳假设易知，$P(n-1)$ 的第一行是
$\tilde{v}_{1m_1}\tilde{v}_{2m_2}\cdots\tilde{v}_{em_e}$，$Q(n-1)$
的第一行是
$\tilde{u}_{11}\tilde{u}_{21}\cdots\tilde{u}_{e1}$。现在将 $v_n$
插入 $P(n-1)$。若 $\tilde{v}_{im_i}>v_n$，则 $I_i^{'}\cup (u_n,
v_n)$ 是 $I\left(\begin{array}{c} u\\v\end{array}\right)$
的一个反链。因此易知若 $i$ 是最小的满足 $\tilde{v}_{im_i}>v_n$
的下标，则 $(u_n, v_n)\in I_i\left(\begin{array}{c}
u\\v\end{array}\right)$；若不存在这样的 $i$，则 $I_d=\{(u_n,
v_n)\}$。从而此引理得证。

 若记 $I_i\left(\begin{array}{c}
u\\v\end{array}\right)=\{(u_{i1},v_{i1}), (u_{i2},v_{i2}),\ldots,
(u_{im_i},v_{im_i})\}$ 且其中有 $u_{i1}<u_{i2}<\cdots<u_{im_i},
v_{i1}>v_{i2}>\cdots>v_{im_i}$ 成立，则 $I_i\left(\begin{array}{c}
v\\u\end{array}\right)=\{(v_{im_i}, u_{im_i}), \ldots,\\ (v_{i2},
u_{i2}), (v_{i1}, u_{i1})\}$ 且 $v_{im_i}<\cdots<v_{i2}<v_{i1},
u_{im_i}>\cdots>u_{i2}>u_{i1}$。因此若 $\pi^{-1
}\xrightarrow{\text{RSK}}(P^{'}, Q^{'})$，则由引理 1.3 知 $P^{'}$
的第一行元素是 $u_{11}u_{21}\cdots u_{d1}$，$Q^{'}$ 的第一行元素是
$v_{1m_1}v_{2m_2}\cdots v_{dm_d}$。即 $P^{'}, Q^{'}$ 的第一行元素与
$Q, P$ 的第一行元素分别相等。

易知，在 RSK 算法执行过程中，$v_{ij}(1\leq j<m_i)$ 比 $v_{rs}(1\leq
s<m_r)$ 先被挤入第二行当且仅当 $u_{i, j+1}<u_{r, s+1}$。设
$\overline{P}, \overline{Q}$ 分别表示移去 $P, Q$ 第一行后所得的
tableau，从而有

\begin{align*}
\left(\begin{array}{c} a\\b\end{array}\right)
&:=\left(\begin{array}{cccccccccc}
u_{12}&\cdots&u_{1m_1}&u_{22}&\cdots&u_{2m_2}&\cdots&u_{d2}&\cdots&u_{dm_d}\\v_{11}&\cdots&v_{1,
m_1-1}&v_{21}&\cdots&v_{2, m_2-1}&\cdots&v_{d1}&\cdots&v_{d,
m_d-1}\end{array}\right)_{sorted}\\&\xrightarrow{\text{RSK}}(\overline{P}
, \overline{Q}).
\end{align*}



设 $\overline{P}^{'}, \overline{Q}^{'}$ 分别表示移去 $P^{'}, Q^{'}$
第一行后所得的 tableau，对 $\left(\begin{array}{c}
v\\u\end{array}\right)$ 进行类似讨论有：


\begin{align*}
 \left(\begin{array}{c}
a^{'}\\b^{'}\end{array}\right) &:=\left(\begin{array}{cccccccccc}
v_{1, m_1-1}&\cdots&v_{11}&v_{2, m_2-1}&\cdots&v_{21}&\cdots&v_{d,
m_d-1}&\cdots&v_{d1}\\u_{1m_1}&\cdots&u_{12}&u_{2m_2}&\cdots&u_{22}&\cdots&u_{dm_d}&\cdots&u_{d2}\end{array}\right)
_{sorted}\\&\xrightarrow{\text{RSK}}(\overline{P}^{'} ,
\overline{Q}^{'}).\end{align*}


 由于 $\left(\begin{array}{c}
a\\b\end{array}\right)=\left(\begin{array}{c}
b^{'}\\a^{'}\end{array}\right)_{sorted}$， 从而由对行数的归纳易知
$({\overline{P}}^{'}, \overline{Q}^{'})=(\overline{Q},
\overline{P})$。 \qed





% \bibliographystyle{cfcbook}
\begin{thebibliography}{99}



\bibitem{Sagan}
B. Sagan, The Symmetric Group, second ed. Graduate Texts in
Mathematics 203, Springer-Verlag, New York, 2001.


\bibitem{Stanley86}
R.P. Stanley, Enumerative Combinatorics, vol. 1. Wadsworth and
Brooks/Cole, Pacific Grove, CA, 1986; second printing, Cambridge
University Press, New York/Cambridge, 1996.

\bibitem{Stanley1999}
R.P. Stanley, Enumerative Combinatorics, vol. 2. Cambridge
University Press, New York/Cambridge, 1999.

\bibitem{SW}
D. Stanton and D. White, Constructive Combinatorics, Springer, New York (1986).


\end{thebibliography}
